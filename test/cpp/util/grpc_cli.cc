/*

 * Copyright 2015 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/*
  A command line tool to talk to a grpc server.
  Run `grpc_cli help` command to see its usage information.

  Example of talking to grpc interop server:
  grpc_cli call localhost:50051 UnaryCall "response_size:10" \
      --protofiles=src/proto/grpc/testing/test.proto --enable_ssl=false

  Options:
    1. --protofiles, use this flag to provide proto files if the server does
       does not have the reflection service.
    2. --proto_path, if your proto file is not under current working directory,
       use this flag to provide a search root. It should work similar to the
       counterpart in protoc. This option is valid only when protofiles is
       provided.
    3. --metadata specifies metadata to be sent to the server, such as:
       --metadata="MyHeaderKey1:Value1:MyHeaderKey2:Value2"
    4. --enable_ssl, whether to use tls.
    5. --use_auth, if set to true, attach a GoogleDefaultCredentials to the call
    6. --infile, input filename (defaults to stdin)
    7. --outfile, output filename (defaults to stdout)
    8. --binary_input, use the serialized request as input. The serialized
       request can be generated by calling something like:
       protoc --proto_path=src/proto/grpc/testing/ \
         --encode=grpc.testing.SimpleRequest \
         src/proto/grpc/testing/messages.proto \
         < input.txt > input.bin
       If this is used and no proto file is provided in the argument list, the
       method string has to be exact in the form of /package.service/method.
    9. --binary_output, use binary format response as output, it can
       be later decoded using protoc:
       protoc --proto_path=src/proto/grpc/testing/ \
       --decode=grpc.testing.SimpleResponse \
       src/proto/grpc/testing/messages.proto \
       < output.bin > output.txt
*/

#include <fstream>
#include <functional>
#include <iostream>

#include <gflags/gflags.h>
#include <grpcpp/support/config.h>
#include "test/cpp/util/cli_credentials.h"
#include "test/cpp/util/grpc_tool.h"
#include "test/cpp/util/test_config.h"

#include <iterator>
#include <pthread.h>

pthread_mutex_t mutex_lock;



DEFINE_string(outfile, "", "Output file (default is stdout)");
grpc::string w_result;
grpc::string b_result;
grpc::string final_result;

extern "C"{
  char *matmul(int,char **);
  char *grad_w(int,char **);
  char *grad_b(int,char **);
}

static bool wPrint(const grpc::string& outfile,
                        const grpc::string& output) {
  if (outfile.empty()) {
    std::cout<<output<<std::endl;
  } else {
    std::ofstream output_file(outfile, std::ios::app | std::ios::binary);
    output_file << output << std::endl;
    output_file.close();
  }
  w_result= output;
  return true;
}

static bool bPrint(const grpc::string& outfile,
                        const grpc::string& output) {
  if (outfile.empty()) {
    std::cout<<output<<std::endl;
  } else {
    std::ofstream output_file(outfile, std::ios::app | std::ios::binary);
    output_file << output << std::endl;
    output_file.close();
  }
  b_result= output;
  return true;
}

static bool SimplePrint(const grpc::string& outfile,
                        const grpc::string& output) {
  if (outfile.empty()) {
    std::cout<<output<<std::endl;
  } else {
    std::ofstream output_file(outfile, std::ios::app | std::ios::binary);
    output_file << output << std::endl;
    output_file.close();
  }
  final_result= output;
  return true;
}

char *matmul(int argc, char **argv) {
   char *arg[5];
  arg[0]= (char*)"matmul";
  char *vec;
  // modify argv vector
  grpc::string a1 = "call"; 
  grpc::string a2 = "localhost:34567";
  grpc::string a3 = "MatMul";
  grpc::string a4 = "tensor1_shape: \"";
  grpc::string a5 = argv[1];
  grpc::string a7 = argv[2];
  
  grpc::string a6 = "\" tensor1: ";
  grpc::string a8 = " tensor2_shape: \"";
  
  grpc::string a9= argv[3];
  grpc::string a11 = argv[4];

  grpc::string a10 = "\" tensor2: ";
  grpc::string a12 = " ";
  
  
  grpc::string av = a4+a5+a6+a7+a8+a9+a10+a11+a12;
  vec = (char *)av.c_str();
  
  arg[1] = (char *)a1.c_str();
  arg[2] = (char *)a2.c_str();
  arg[3] = (char *)a3.c_str();

  arg[4] = vec;

  argc = 5;

  grpc::string res = "";
  int ret = grpc::testing::GrpcToolMainLib(
      argc, (const char**)arg, grpc::testing::CliCredentials(),
      std::bind(SimplePrint, FLAGS_outfile, std::placeholders::_1));
  if (ret == 0) {
    res = "";
  }
  
  return (char* )final_result.c_str();
}

char* grad_w(int argc, char** argv) {
    pthread_mutex_lock(&mutex_lock);
    char* arg[5];
    arg[0] = (char*)"grad_w";
    char* vec;
    // modify argv vector
    grpc::string a1 = "call";
    grpc::string a2 = "localhost:45678";
    grpc::string a3 = "GetGrad_W";
    grpc::string a4 = "tensor1_shape: \"";
    grpc::string a5 = argv[1];
    grpc::string a7 = argv[2];

    grpc::string a6 = "\" tensor1: ";
    grpc::string a8 = " tensor2_shape: \"";

    grpc::string a9 = argv[3];
    grpc::string a11 = argv[4];

    grpc::string a10 = "\" tensor2: ";
    grpc::string a12 = " ";

    grpc::string av = a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12;
    vec = (char*)av.c_str();

    arg[1] = (char*)a1.c_str();
    arg[2] = (char*)a2.c_str();
    arg[3] = (char*)a3.c_str();

    arg[4] = vec;

    argc = 5;

    grpc::string res = "";
    int ret = grpc::testing::GrpcToolMainLib(
        argc, (const char**)arg, grpc::testing::CliCredentials(),
        std::bind(wPrint, FLAGS_outfile, std::placeholders::_1));
    if (ret == 0) {
      res = "";
    }
  pthread_mutex_unlock(&mutex_lock);
  return (char*)w_result.c_str();
}

char *grad_b(int argc, char **argv) {
  char* arg[5];
  arg[0] = (char*)"grad_b";
  char* vec;
  // modify argv vector
  grpc::string a1 = "call";
  grpc::string a2 = "localhost:56789";
  grpc::string a3 = "GetGrad_b";
  grpc::string a4 = "tensor1_shape: \"";
  grpc::string a5 = argv[1];
  grpc::string a7 = argv[2];

  grpc::string a6 = "\" tensor1: ";
  grpc::string a8 = " tensor2_shape: \"";

  grpc::string a9 = argv[3];
  grpc::string a11 = argv[4];

  grpc::string a10 = "\" tensor2: ";
  grpc::string a12 = " ";

  grpc::string av = a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12;
  vec = (char*)av.c_str();

  arg[1] = (char*)a1.c_str();
  arg[2] = (char*)a2.c_str();
  arg[3] = (char*)a3.c_str();

  arg[4] = vec;

  argc = 5;

  grpc::string res = "";
  int ret = grpc::testing::GrpcToolMainLib(
      argc, (const char**)arg, grpc::testing::CliCredentials(),
      std::bind(bPrint, FLAGS_outfile, std::placeholders::_1));
  if (ret == 0) {
    res = "";
  }
  return (char*)b_result.c_str();
}

int main(int argc, char** arg2) {
  
  char *argv[5];
  argv[0] = (char*)"MatMul";
  argv[1] = (char*)"[1,2]";
  argv[2] = (char*)"[1,1]";
  argv[3] = (char*)"[1]";
  argv[4] = (char*)"[0]";
  char *res;
  res = matmul(5,argv);


  argv[0] = (char*)"GetGrad_W";
  res = grad_w(5,argv);

  argv[0] = (char*)"GetGrad_b";
  res = grad_b(5,argv);

  return 0;
}
